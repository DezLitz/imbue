package generator

import (
	"bytes"
	"fmt"
	"os"
	"path"

	"github.com/dave/jennifer/jen"
)

const (
	// pkgPath is the package path for the imbue package.
	pkgPath = "github.com/dogmatiq/imbue"

	// maxDependencies is the maximum number of dependencies that can be
	// provided in one invocation.
	maxDependencies = 8

	decoratorFuncName   = "dec"
	constructorFuncName = "ctor"
	invokeFuncName      = "fn"
)

// Generate generates a file.
func Generate(
	filename string,
	generator func(code *jen.File),
) error {
	code := jen.NewFilePathName(pkgPath, path.Base(pkgPath))
	code.HeaderComment("Code generated by Imbue's build process. DO NOT EDIT.")

	generator(code)

	buf := &bytes.Buffer{}
	if err := code.Render(buf); err != nil {
		return fmt.Errorf("unable to generate code: %w", err)
	}

	if err := os.WriteFile(
		filename,
		buf.Bytes(),
		0644,
	); err != nil {
		return fmt.Errorf("unable to write to file: %w", err)
	}

	return nil
}

// containerVar returns the name to use for the container parameter.
func containerVar() *jen.Statement {
	return jen.Id("con")
}

// contextVar returns the name to use for the context parameter.
func contextVar() *jen.Statement {
	return jen.Id("ctx")
}

// waitGroupVar returns the name to use for the wait group parameter.
func waitGroupVar() *jen.Statement {
	return jen.Id("g")
}

// constructorVar returns the name to use for the constructor function.
func constructorVar() *jen.Statement {
	return jen.Id(constructorFuncName)
}

// decoratorVar returns the name to use for the decorator function.
func decoratorVar() *jen.Statement {
	return jen.Id(decoratorFuncName)
}

// invokeFuncVar returns the name to use for the function that is invoked.
func invokeFuncVar() *jen.Statement {
	return jen.Id(invokeFuncName)
}

// containerType returns the type to use for the container parameter.
func containerType() *jen.Statement {
	return jen.Op("*").Qual(pkgPath, "Container")
}

// stdContextType returns the type to use for a context.Context parameter.
func stdContextType() *jen.Statement {
	return jen.Qual("context", "Context")
}

// imbueContextType returns the type to use for Imbue's own context type.
func imbueContextType() *jen.Statement {
	return jen.Qual(pkgPath, "Context")
}

// waitGroupType returns the type to use for the wait group parameter.
func waitGroupType() *jen.Statement {
	return jen.Op("*").Qual(pkgPath, "WaitGroup")
}

// containerParam returns the name and type for the container parameter.
func containerParam() *jen.Statement {
	return containerVar().Add(containerType())
}

// stdContextParam returns the name and type of a context.Context parameter.
func stdContextParam() *jen.Statement {
	return contextVar().Add(stdContextType())
}

// imbueContextParam returns the name and type to use for Imbue's context
// parameter.
func imbueContextParam() *jen.Statement {
	return contextVar().Add(imbueContextType())
}

// waitGroupParam returns the name and type for the wait group parameter.
func waitGroupParam() *jen.Statement {
	return waitGroupVar().Add(waitGroupType())
}

// declaringTypeString returns the type name to use for the type being declared.
func declaringTypeString(depCount int) string {
	return "T"
}

// declaringType returns the type name to use for the type being declared.
func declaringType(depCount int) *jen.Statement {
	return jen.Id(declaringTypeString(depCount))
}

// declaringVar returns the name to use for the value of the type being declared.
func declaringVar(depCount int) *jen.Statement {
	return jen.Id("v")
}

// declaringDeclVar returns the name to use for the varaible containing the
// n'th dependency's declaration.
func declaringDeclVar(depCount int) *jen.Statement {
	return jen.Id("t")
}

// namedTypeString returns the type name to use for a named dependency.
func namedTypeString(depCount int) string {
	return "N"
}

// namedType returns the type name to use for a named dependency.
func namedType(depCount int) *jen.Statement {
	return jen.Id(namedTypeString(depCount))
}

// groupedTypeString returns the type name to use for a grouped dependency.
func groupedTypeString(depCount int) string {
	return "G"
}

// groupedType returns the type name to use for a grouped dependency.
func groupedType(depCount int) *jen.Statement {
	return jen.Id(groupedTypeString(depCount))
}

// dependencyType returns the type name to use for the n'th dependency.
func dependencyType(depCount, n int) *jen.Statement {
	if depCount == 1 {
		return jen.Id("D")
	}

	return jen.Id(
		fmt.Sprintf("D%d", n+1),
	)
}

// dependencyVar returns the parameter name to use for the n'th dependency.
func dependencyVar(depCount, n int) *jen.Statement {
	return jen.Id(
		fmt.Sprintf("v%d", n+1),
	)
}

// dependencyDeclVar returns the name to use for the varaible containing the
// n'th dependency's declaration.
func dependencyDeclVar(depCount, n int) *jen.Statement {
	return jen.Id(
		fmt.Sprintf("d%d", n+1),
	)
}

// types returns the type names to use for a function with the given number
// of dependencies.
func types(depCount int, types ...jen.Code) []jen.Code {
	for n := 0; n < depCount; n++ {
		types = append(
			types,
			dependencyType(depCount, n),
		)
	}

	return []jen.Code{
		jen.List(types...).Any(),
	}
}

// inputVars returns the names of the input parameters to a function with the
// given number of dependencies.
func inputVars(depCount int, params ...jen.Code) []jen.Code {
	for n := 0; n < depCount; n++ {
		params = append(
			params,
			dependencyVar(depCount, n),
		)
	}
	return params
}

// inputTypes returns the types of the input parameters to a function with
// the given number of dependencies.
func inputTypes(depCount int, types ...jen.Code) []jen.Code {
	for n := 0; n < depCount; n++ {
		types = append(
			types,
			dependencyType(depCount, n),
		)
	}

	return types
}

// inputParams returns the the input parameters (both names and types) to a
// function with the given number of dependencies, including the "ctx"
// parameter.
func inputParams(ctxType *jen.Statement, depCount int) []jen.Code {
	params := []jen.Code{
		contextVar().Add(ctxType),
	}

	for n := 0; n < depCount; n++ {
		typ := dependencyType(depCount, n)
		name := dependencyVar(depCount, n)

		params = append(
			params,
			name.Add(typ),
		)
	}

	return params
}

package generator

import (
	"fmt"
	"io"
	"path"

	"github.com/dave/jennifer/jen"
)

const (
	// pkgPath is the package path for the imbue package.
	pkgPath = "github.com/dogmatiq/imbue"

	// maxDependencies is the maximum number of dependencies that can be
	// provided in one invocation.
	maxDependencies = 2
)

// Generate generates the code that implements the CallX, InvokeX, and WithX
// functions.
func Generate(w io.Writer) error {
	code := jen.NewFilePathName(pkgPath, path.Base(pkgPath))
	code.HeaderComment("Code generated by Imbue's build process. DO NOT EDIT.")

	for depCount := 0; depCount <= maxDependencies; depCount++ {
		generateWithFunc(code, depCount)
	}

	for depCount := 1; depCount <= maxDependencies; depCount++ {
		generateInvokeWithFunc(code, depCount)
	}

	// for depCount := 1; depCount <= maxDependencies; depCount++ {
	// 	generateCallWithFunc(code, depCount)
	// }

	return code.Render(w)
}

// dependencyTypeName returns the type name to use for the n'th dependency.
func dependencyTypeName(depCount, n int) string {
	if depCount == 1 {
		return "D"
	}

	return fmt.Sprintf("D%d", n+1)
}

// dependencyParamName returns the parameter name to use for the n'th dependency.
func dependencyParamName(depCount, n int) string {
	if depCount == 1 {
		return "dep"
	}

	return fmt.Sprintf("dep%d", n+1)
}

// typeParamers returns the type parameters to use for a function with the given
// number of dependencies.
func typeParams(includeT bool, depCount int) []jen.Code {
	var types []jen.Code

	if includeT {
		types = append(types, jen.Id("T"))
	}

	for n := 0; n < depCount; n++ {
		typeName := dependencyTypeName(depCount, n)
		types = append(types, jen.Id(typeName))
	}

	return []jen.Code{
		jen.List(types...).Any(),
	}
}

// inputParamNames returns the names of the input parameters to a function with
// the given number of dependencies, including the "ctx" parameter.
func inputParamNames(depCount int) []jen.Code {
	params := []jen.Code{
		jen.Id("ctx"),
	}

	for n := 0; n < depCount; n++ {
		params = append(
			params,
			jen.Id(dependencyParamName(depCount, n)),
		)
	}
	return params
}

// inputParamTypes returns the types of the input parameters to a function with
// the given number of dependencies, including the "ctx" parameter.
func inputParamTypes(ctxType *jen.Statement, depCount int) []jen.Code {
	types := []jen.Code{
		ctxType,
	}

	for n := 0; n < depCount; n++ {
		name := dependencyTypeName(depCount, n)
		types = append(
			types,
			jen.Id(name),
		)
	}

	return types
}

// inputParams returns the the input parameters (both names and types) to a
// function with the given number of dependencies, including the "ctx"
// parameter.
func inputParams(ctxType *jen.Statement, depCount int) []jen.Code {
	params := []jen.Code{
		contextName().Add(ctxType),
	}

	for n := 0; n < depCount; n++ {
		typ := dependencyTypeName(depCount, n)
		name := dependencyParamName(depCount, n)

		params = append(
			params,
			jen.Id(name).Id(typ),
		)
	}

	return params
}

func containerName() *jen.Statement {
	return jen.Id("con")
}

func contextName() *jen.Statement {
	return jen.Id("ctx")
}

func containerType() *jen.Statement {
	return jen.Op("*").Qual(pkgPath, "Container")
}

func stdContextType() *jen.Statement {
	return jen.Qual("context", "Context")
}

func imbueContextType() *jen.Statement {
	return jen.Op("*").Qual(pkgPath, "Context")
}

func containerParam() *jen.Statement {
	return containerName().Add(containerType())
}

func stdContextParam() *jen.Statement {
	return contextName().Add(stdContextType())
}

func imbueContextParam() *jen.Statement {
	return contextName().Add(imbueContextType())
}

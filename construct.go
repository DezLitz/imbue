package imbue

import "fmt"

// constructor is a container for a function that constructs a value of type T.
//
// It implements the userFunction interface.
type constructor[T any] struct {
	// impl is the constructor implementation. It is typically a closure
	// generated by the WithX() functions. It wraps the user-provided
	// constructor function to provide a common signature.
	impl func(*Context) (T, error)

	// loc is the location of the code that provided the constructor.
	loc location

	// rawErr, if true, indicates that Call() should return the error exactly as
	// it is returned by the constructor implementation, without wrapping it to
	// provide additional context.
	rawErr bool
}

// Call invokes the constructor and returns the constructed value.
func (c constructor[T]) Call(ctx *Context) (T, error) {
	ctx = &Context{
		Context:  ctx,
		deferrer: ctx.deferrer,
		scope:    c,
	}

	v, err := c.impl(ctx)
	if err != nil {
		if c.rawErr {
			return v, err
		}

		return v, fmt.Errorf(
			"%s failed: %w",
			c,
			err,
		)
	}

	return v, nil
}

// Location returns the location of the code that provided the constructor.
//
// This is typically the location of the call to the WithX() function, not the
// constructor implementation function definition.
func (c constructor[T]) Location() location {
	return c.loc
}

// String returns a description of the constructor for use in error messages.
func (c constructor[T]) String() string {
	return fmt.Sprintf(
		"%s constructor (%s)",
		typeOf[T](),
		c.loc,
	)
}

// Declare declares a constructor for values of type T.
func (d *declarationOf[T]) Declare(
	impl func(*Context) (T, error),
	deps ...declaration,
) {
	ctor := constructor[T]{
		impl,
		findLocation(),
		d.isSelfDeclaring,
	}

	for _, dep := range deps {
		d.dependsOn(dep, ctor)
	}

	d.m.Lock()
	defer d.m.Unlock()

	if d.isDeclared {
		isSelfDeclaring := d.isSelfDeclaring

		if isSelfDeclaring {
			panic(fmt.Sprintf(
				"explicit declaration of %s is disallowed",
				ctor,
			))
		}

		panic(fmt.Sprintf(
			"%s collides with existing constructor declared at %s",
			ctor,
			d.constructor.Location(),
		))
	}

	d.isDeclared = true
	d.constructor = ctor
}

// construct initializes d.value.
func (d *declarationOf[T]) construct(ctx *Context) error {
	if !d.isDeclared {
		return undeclaredConstructorError{d}
	}

	v, err := d.constructor.Call(ctx)
	if err != nil {
		return err
	}

	d.value = v

	return nil
}

// undeclaredConstructorError is an error returned by declarationOf[T].Resolve()
// when no constructor has been declared for T.
type undeclaredConstructorError struct {
	Declaration declaration
}

func (e undeclaredConstructorError) Error() string {
	return fmt.Sprintf(
		"no constructor is declared for %s",
		e.Declaration.Type(),
	)
}

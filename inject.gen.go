// Code generated by Imbue's build process. DO NOT EDIT.

package imbue

// Inject1 describes how to initialize values of type T after construction using
// a single additional dependency.
func Inject1[T, D any](
	con *Container,
	fn func(*Context, T, D) error,
	options ...InjectOption,
) {
	t := get[T](con)

	d1 := get[D](con)
	if err := t.AddDependency(d1); err != nil {
		panic(err)
	}

	t.AddInitializer(
		func(ctx *Context, v T) error {
			v1, err := d1.Resolve(ctx)
			if err != nil {
				return err
			}

			return fn(ctx, v, v1)
		},
	)
}

// Inject2 describes how to initialize values of type T after construction using
// 2 additional dependencies.
func Inject2[T, D1, D2 any](
	con *Container,
	fn func(*Context, T, D1, D2) error,
	options ...InjectOption,
) {
	t := get[T](con)

	d1 := get[D1](con)
	if err := t.AddDependency(d1); err != nil {
		panic(err)
	}

	d2 := get[D2](con)
	if err := t.AddDependency(d2); err != nil {
		panic(err)
	}

	t.AddInitializer(
		func(ctx *Context, v T) error {
			v1, err := d1.Resolve(ctx)
			if err != nil {
				return err
			}

			v2, err := d2.Resolve(ctx)
			if err != nil {
				return err
			}

			return fn(ctx, v, v1, v2)
		},
	)
}

// Inject3 describes how to initialize values of type T after construction using
// 3 additional dependencies.
func Inject3[T, D1, D2, D3 any](
	con *Container,
	fn func(*Context, T, D1, D2, D3) error,
	options ...InjectOption,
) {
	t := get[T](con)

	d1 := get[D1](con)
	if err := t.AddDependency(d1); err != nil {
		panic(err)
	}

	d2 := get[D2](con)
	if err := t.AddDependency(d2); err != nil {
		panic(err)
	}

	d3 := get[D3](con)
	if err := t.AddDependency(d3); err != nil {
		panic(err)
	}

	t.AddInitializer(
		func(ctx *Context, v T) error {
			v1, err := d1.Resolve(ctx)
			if err != nil {
				return err
			}

			v2, err := d2.Resolve(ctx)
			if err != nil {
				return err
			}

			v3, err := d3.Resolve(ctx)
			if err != nil {
				return err
			}

			return fn(ctx, v, v1, v2, v3)
		},
	)
}

// Inject4 describes how to initialize values of type T after construction using
// 4 additional dependencies.
func Inject4[T, D1, D2, D3, D4 any](
	con *Container,
	fn func(*Context, T, D1, D2, D3, D4) error,
	options ...InjectOption,
) {
	t := get[T](con)

	d1 := get[D1](con)
	if err := t.AddDependency(d1); err != nil {
		panic(err)
	}

	d2 := get[D2](con)
	if err := t.AddDependency(d2); err != nil {
		panic(err)
	}

	d3 := get[D3](con)
	if err := t.AddDependency(d3); err != nil {
		panic(err)
	}

	d4 := get[D4](con)
	if err := t.AddDependency(d4); err != nil {
		panic(err)
	}

	t.AddInitializer(
		func(ctx *Context, v T) error {
			v1, err := d1.Resolve(ctx)
			if err != nil {
				return err
			}

			v2, err := d2.Resolve(ctx)
			if err != nil {
				return err
			}

			v3, err := d3.Resolve(ctx)
			if err != nil {
				return err
			}

			v4, err := d4.Resolve(ctx)
			if err != nil {
				return err
			}

			return fn(ctx, v, v1, v2, v3, v4)
		},
	)
}

// Inject5 describes how to initialize values of type T after construction using
// 5 additional dependencies.
func Inject5[T, D1, D2, D3, D4, D5 any](
	con *Container,
	fn func(*Context, T, D1, D2, D3, D4, D5) error,
	options ...InjectOption,
) {
	t := get[T](con)

	d1 := get[D1](con)
	if err := t.AddDependency(d1); err != nil {
		panic(err)
	}

	d2 := get[D2](con)
	if err := t.AddDependency(d2); err != nil {
		panic(err)
	}

	d3 := get[D3](con)
	if err := t.AddDependency(d3); err != nil {
		panic(err)
	}

	d4 := get[D4](con)
	if err := t.AddDependency(d4); err != nil {
		panic(err)
	}

	d5 := get[D5](con)
	if err := t.AddDependency(d5); err != nil {
		panic(err)
	}

	t.AddInitializer(
		func(ctx *Context, v T) error {
			v1, err := d1.Resolve(ctx)
			if err != nil {
				return err
			}

			v2, err := d2.Resolve(ctx)
			if err != nil {
				return err
			}

			v3, err := d3.Resolve(ctx)
			if err != nil {
				return err
			}

			v4, err := d4.Resolve(ctx)
			if err != nil {
				return err
			}

			v5, err := d5.Resolve(ctx)
			if err != nil {
				return err
			}

			return fn(ctx, v, v1, v2, v3, v4, v5)
		},
	)
}

// Inject6 describes how to initialize values of type T after construction using
// 6 additional dependencies.
func Inject6[T, D1, D2, D3, D4, D5, D6 any](
	con *Container,
	fn func(*Context, T, D1, D2, D3, D4, D5, D6) error,
	options ...InjectOption,
) {
	t := get[T](con)

	d1 := get[D1](con)
	if err := t.AddDependency(d1); err != nil {
		panic(err)
	}

	d2 := get[D2](con)
	if err := t.AddDependency(d2); err != nil {
		panic(err)
	}

	d3 := get[D3](con)
	if err := t.AddDependency(d3); err != nil {
		panic(err)
	}

	d4 := get[D4](con)
	if err := t.AddDependency(d4); err != nil {
		panic(err)
	}

	d5 := get[D5](con)
	if err := t.AddDependency(d5); err != nil {
		panic(err)
	}

	d6 := get[D6](con)
	if err := t.AddDependency(d6); err != nil {
		panic(err)
	}

	t.AddInitializer(
		func(ctx *Context, v T) error {
			v1, err := d1.Resolve(ctx)
			if err != nil {
				return err
			}

			v2, err := d2.Resolve(ctx)
			if err != nil {
				return err
			}

			v3, err := d3.Resolve(ctx)
			if err != nil {
				return err
			}

			v4, err := d4.Resolve(ctx)
			if err != nil {
				return err
			}

			v5, err := d5.Resolve(ctx)
			if err != nil {
				return err
			}

			v6, err := d6.Resolve(ctx)
			if err != nil {
				return err
			}

			return fn(ctx, v, v1, v2, v3, v4, v5, v6)
		},
	)
}

// Inject7 describes how to initialize values of type T after construction using
// 7 additional dependencies.
func Inject7[T, D1, D2, D3, D4, D5, D6, D7 any](
	con *Container,
	fn func(*Context, T, D1, D2, D3, D4, D5, D6, D7) error,
	options ...InjectOption,
) {
	t := get[T](con)

	d1 := get[D1](con)
	if err := t.AddDependency(d1); err != nil {
		panic(err)
	}

	d2 := get[D2](con)
	if err := t.AddDependency(d2); err != nil {
		panic(err)
	}

	d3 := get[D3](con)
	if err := t.AddDependency(d3); err != nil {
		panic(err)
	}

	d4 := get[D4](con)
	if err := t.AddDependency(d4); err != nil {
		panic(err)
	}

	d5 := get[D5](con)
	if err := t.AddDependency(d5); err != nil {
		panic(err)
	}

	d6 := get[D6](con)
	if err := t.AddDependency(d6); err != nil {
		panic(err)
	}

	d7 := get[D7](con)
	if err := t.AddDependency(d7); err != nil {
		panic(err)
	}

	t.AddInitializer(
		func(ctx *Context, v T) error {
			v1, err := d1.Resolve(ctx)
			if err != nil {
				return err
			}

			v2, err := d2.Resolve(ctx)
			if err != nil {
				return err
			}

			v3, err := d3.Resolve(ctx)
			if err != nil {
				return err
			}

			v4, err := d4.Resolve(ctx)
			if err != nil {
				return err
			}

			v5, err := d5.Resolve(ctx)
			if err != nil {
				return err
			}

			v6, err := d6.Resolve(ctx)
			if err != nil {
				return err
			}

			v7, err := d7.Resolve(ctx)
			if err != nil {
				return err
			}

			return fn(ctx, v, v1, v2, v3, v4, v5, v6, v7)
		},
	)
}

// Inject8 describes how to initialize values of type T after construction using
// 8 additional dependencies.
func Inject8[T, D1, D2, D3, D4, D5, D6, D7, D8 any](
	con *Container,
	fn func(*Context, T, D1, D2, D3, D4, D5, D6, D7, D8) error,
	options ...InjectOption,
) {
	t := get[T](con)

	d1 := get[D1](con)
	if err := t.AddDependency(d1); err != nil {
		panic(err)
	}

	d2 := get[D2](con)
	if err := t.AddDependency(d2); err != nil {
		panic(err)
	}

	d3 := get[D3](con)
	if err := t.AddDependency(d3); err != nil {
		panic(err)
	}

	d4 := get[D4](con)
	if err := t.AddDependency(d4); err != nil {
		panic(err)
	}

	d5 := get[D5](con)
	if err := t.AddDependency(d5); err != nil {
		panic(err)
	}

	d6 := get[D6](con)
	if err := t.AddDependency(d6); err != nil {
		panic(err)
	}

	d7 := get[D7](con)
	if err := t.AddDependency(d7); err != nil {
		panic(err)
	}

	d8 := get[D8](con)
	if err := t.AddDependency(d8); err != nil {
		panic(err)
	}

	t.AddInitializer(
		func(ctx *Context, v T) error {
			v1, err := d1.Resolve(ctx)
			if err != nil {
				return err
			}

			v2, err := d2.Resolve(ctx)
			if err != nil {
				return err
			}

			v3, err := d3.Resolve(ctx)
			if err != nil {
				return err
			}

			v4, err := d4.Resolve(ctx)
			if err != nil {
				return err
			}

			v5, err := d5.Resolve(ctx)
			if err != nil {
				return err
			}

			v6, err := d6.Resolve(ctx)
			if err != nil {
				return err
			}

			v7, err := d7.Resolve(ctx)
			if err != nil {
				return err
			}

			v8, err := d8.Resolve(ctx)
			if err != nil {
				return err
			}

			return fn(ctx, v, v1, v2, v3, v4, v5, v6, v7, v8)
		},
	)
}

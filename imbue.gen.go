// Code generated by Imbue's build process. DO NOT EDIT.

package imbue

import (
	"context"
	"runtime"
)

// With0 describes how to construct values of type T.
func With0[T any](
	con *Container,
	fn func(*Context) (T, error),
) {
	_, file, line, _ := runtime.Caller(1)

	t := get[T](con)

	if err := t.Declare(
		file,
		line,
		func() (constructor[T], error) {
			return fn, nil
		},
	); err != nil {
		panic(err)
	}
}

// With1 describes how to construct values of type T from a single dependency.
func With1[T, D any](
	con *Container,
	fn func(*Context, D) (T, error),
) {
	_, file, line, _ := runtime.Caller(1)

	t := get[T](con)

	if err := t.Declare(
		file,
		line,
		func() (constructor[T], error) {
			d1 := get[D](con)
			if err := t.AddDependency(d1); err != nil {
				return nil, err
			}

			return func(ctx *Context) (v T, _ error) {
				v1, err := d1.Resolve(ctx)
				if err != nil {
					return v, err
				}

				return fn(ctx, v1)
			}, nil
		},
	); err != nil {
		panic(err)
	}
}

// With2 describes how to construct values of type T from 2 dependencies.
func With2[T, D1, D2 any](
	con *Container,
	fn func(*Context, D1, D2) (T, error),
) {
	_, file, line, _ := runtime.Caller(1)

	t := get[T](con)

	if err := t.Declare(
		file,
		line,
		func() (constructor[T], error) {
			d1 := get[D1](con)
			if err := t.AddDependency(d1); err != nil {
				return nil, err
			}

			d2 := get[D2](con)
			if err := t.AddDependency(d2); err != nil {
				return nil, err
			}

			return func(ctx *Context) (v T, _ error) {
				v1, err := d1.Resolve(ctx)
				if err != nil {
					return v, err
				}

				v2, err := d2.Resolve(ctx)
				if err != nil {
					return v, err
				}

				return fn(ctx, v1, v2)
			}, nil
		},
	); err != nil {
		panic(err)
	}
}

// Invoke1 calls a function with a single dependency.
func Invoke1[D any](
	ctx context.Context,
	con *Container,
	fn func(context.Context, D) error,
) error {
	rctx := rootContext(ctx)

	v1, err := get[D](con).Resolve(rctx)
	if err != nil {
		return err
	}

	return fn(ctx, v1)
}

// Invoke2 calls a function with 2 dependencies.
func Invoke2[D1, D2 any](
	ctx context.Context,
	con *Container,
	fn func(context.Context, D1, D2) error,
) error {
	rctx := rootContext(ctx)

	v1, err := get[D1](con).Resolve(rctx)
	if err != nil {
		return err
	}

	v2, err := get[D2](con).Resolve(rctx)
	if err != nil {
		return err
	}

	return fn(ctx, v1, v2)
}

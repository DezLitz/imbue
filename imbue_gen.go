// Code generated by Imbue's build process. DO NOT EDIT.

package imbue

import "context"

// With0 describes how to construct values of type T.
func With0[T any](
	con *Container,
	fn func(*Context) (T, error),
) {
	register(
		con,
		func(ctx *Context, con *Container) (value T, _ error) {
			return fn(ctx)
		},
	)
}

// With1 describes how to construct values of type T from a single dependency.
func With1[T, D any](
	con *Container,
	fn func(*Context, D) (T, error),
) {
	register(
		con,
		func(ctx *Context, con *Container) (value T, _ error) {
			dep, err := get[D](con)
			if err != nil {
				return value, err
			}
			return fn(ctx, dep)
		},
	)
}

// With2 describes how to construct values of type T from 2 dependencies.
func With2[T, D1, D2 any](
	con *Container,
	fn func(*Context, D1, D2) (T, error),
) {
	register(
		con,
		func(ctx *Context, con *Container) (value T, _ error) {
			dep1, err := get[D1](con)
			if err != nil {
				return value, err
			}
			dep2, err := get[D2](con)
			if err != nil {
				return value, err
			}
			return fn(ctx, dep1, dep2)
		},
	)
}

// InvokeWith1 calls a function with a single dependency.
func InvokeWith1[D any](
	ctx context.Context,
	con *Container,
	fn func(context.Context, D) error,
) error {
	dep, err := get[D](con)
	if err != nil {
		return err
	}
	return fn(ctx, dep)
}

// InvokeWith2 calls a function with 2 dependencies.
func InvokeWith2[D1, D2 any](
	ctx context.Context,
	con *Container,
	fn func(context.Context, D1, D2) error,
) error {
	dep1, err := get[D1](con)
	if err != nil {
		return err
	}
	dep2, err := get[D2](con)
	if err != nil {
		return err
	}
	return fn(ctx, dep1, dep2)
}

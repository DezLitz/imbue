// Code generated by Imbue's build process. DO NOT EDIT.

package imbue

import "context"

// Invoke1 calls a function with a single dependency.
func Invoke1[D any](
	ctx context.Context,
	con *Container,
	fn func(context.Context, D) error,
	options ...InvokeOption,
) error {
	rctx := invokeContext(ctx, con)

	v1, err := get[D](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	return filterInvokeError(fn(ctx, v1))
}

// Invoke2 calls a function with 2 dependencies.
func Invoke2[D1, D2 any](
	ctx context.Context,
	con *Container,
	fn func(context.Context, D1, D2) error,
	options ...InvokeOption,
) error {
	rctx := invokeContext(ctx, con)

	v1, err := get[D1](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v2, err := get[D2](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	return filterInvokeError(fn(ctx, v1, v2))
}

// Invoke3 calls a function with 3 dependencies.
func Invoke3[D1, D2, D3 any](
	ctx context.Context,
	con *Container,
	fn func(context.Context, D1, D2, D3) error,
	options ...InvokeOption,
) error {
	rctx := invokeContext(ctx, con)

	v1, err := get[D1](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v2, err := get[D2](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v3, err := get[D3](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	return filterInvokeError(fn(ctx, v1, v2, v3))
}

// Invoke4 calls a function with 4 dependencies.
func Invoke4[D1, D2, D3, D4 any](
	ctx context.Context,
	con *Container,
	fn func(context.Context, D1, D2, D3, D4) error,
	options ...InvokeOption,
) error {
	rctx := invokeContext(ctx, con)

	v1, err := get[D1](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v2, err := get[D2](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v3, err := get[D3](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v4, err := get[D4](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	return filterInvokeError(fn(ctx, v1, v2, v3, v4))
}

// Invoke5 calls a function with 5 dependencies.
func Invoke5[D1, D2, D3, D4, D5 any](
	ctx context.Context,
	con *Container,
	fn func(context.Context, D1, D2, D3, D4, D5) error,
	options ...InvokeOption,
) error {
	rctx := invokeContext(ctx, con)

	v1, err := get[D1](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v2, err := get[D2](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v3, err := get[D3](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v4, err := get[D4](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v5, err := get[D5](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	return filterInvokeError(fn(ctx, v1, v2, v3, v4, v5))
}

// Invoke6 calls a function with 6 dependencies.
func Invoke6[D1, D2, D3, D4, D5, D6 any](
	ctx context.Context,
	con *Container,
	fn func(context.Context, D1, D2, D3, D4, D5, D6) error,
	options ...InvokeOption,
) error {
	rctx := invokeContext(ctx, con)

	v1, err := get[D1](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v2, err := get[D2](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v3, err := get[D3](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v4, err := get[D4](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v5, err := get[D5](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v6, err := get[D6](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	return filterInvokeError(fn(ctx, v1, v2, v3, v4, v5, v6))
}

// Invoke7 calls a function with 7 dependencies.
func Invoke7[D1, D2, D3, D4, D5, D6, D7 any](
	ctx context.Context,
	con *Container,
	fn func(context.Context, D1, D2, D3, D4, D5, D6, D7) error,
	options ...InvokeOption,
) error {
	rctx := invokeContext(ctx, con)

	v1, err := get[D1](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v2, err := get[D2](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v3, err := get[D3](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v4, err := get[D4](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v5, err := get[D5](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v6, err := get[D6](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v7, err := get[D7](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	return filterInvokeError(fn(ctx, v1, v2, v3, v4, v5, v6, v7))
}

// Invoke8 calls a function with 8 dependencies.
func Invoke8[D1, D2, D3, D4, D5, D6, D7, D8 any](
	ctx context.Context,
	con *Container,
	fn func(context.Context, D1, D2, D3, D4, D5, D6, D7, D8) error,
	options ...InvokeOption,
) error {
	rctx := invokeContext(ctx, con)

	v1, err := get[D1](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v2, err := get[D2](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v3, err := get[D3](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v4, err := get[D4](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v5, err := get[D5](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v6, err := get[D6](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v7, err := get[D7](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	v8, err := get[D8](con).Resolve(rctx)
	if err != nil {
		return filterInvokeError(err)
	}

	return filterInvokeError(fn(ctx, v1, v2, v3, v4, v5, v6, v7, v8))
}
